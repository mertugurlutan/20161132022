Project Euler
Soru 42:
import java.util.Arrays;
	
	
	public final class p052 implements EulerSolution {
		
		public static void main(String[] args) {
			System.out.println(new p052().run());
		}
		
		
		public String run() {
			for (int i = 1; ; i++) {
				if (i > Integer.MAX_VALUE / 6)
					throw new ArithmeticException("Overflow");
				if (multiplesHaveSameDigits(i))
					return Integer.toString(i);
			}
		}
		
		
		private static boolean multiplesHaveSameDigits(int x) {
			for (int i = 2; i <= 6; i++) {
				if (!Arrays.equals(toSortedDigits(x), toSortedDigits(i * x)))
					return false;
			}
			return true;
		}
		
		
		private static char[] toSortedDigits(int x) {
			char[] result = Integer.toString(x).toCharArray();
			Arrays.sort(result);
			return result;
		}
		
	}


Soru 162:
import java.math.BigInteger;
	
	
	public final class p162 implements EulerSolution {
		
		public static void main(String[] args) {
			System.out.println(new p162().run());
		}
		
		
		/* 
		 * Among the set of n-digit hexadecimal numbers, how many of them:
		 *   
		 *   Are there in total?: 15*16^(n-1).
		 *   
		 *   Have no 0?: 15^n.
		 *   Have no 1?: 14*15^(n-1).
		 *   Have no A?: 14*15^(n-1).
		 *   
		 *   Have some 0?: 15*16^(n-1) - 15^n.
		 *   Have some 1?: 15*16^(n-1) - 14*15^(n-1).
		 *   Have some A?: 15*16^(n-1) - 14*15^(n-1).
		 *   
		 *   Have no 0 and have no 1?: 14^n.
		 *   Have no 0 and have no A?: 14^n.
		 *   Have no 1 and have no A?: 13*14^(n-1).
		 *   
		 *   Have some 0 or have some 1: 15*16^(n-1) - 14^n.
		 *   Have some 0 or have some A: 15*16^(n-1) - 14^n.
		 *   Have some 1 or have some A: 15*16^(n-1) - 13*14^(n-1).
		 *   
		 *   Note: (Have X) + (Have Y) = (Have X or have Y) + (Have X and have Y).
		 *   Have some 0 and have some 1: (15*16^(n-1) - 15^n) + (15*16^(n-1) - 14*15^(n-1)) - (15*16^(n-1) - 14^n) = 15*16^(n-1) - 29*15^(n-1) + 14^n.
		 *   Have some 0 and have some A: (15*16^(n-1) - 15^n) + (15*16^(n-1) - 14*15^(n-1)) - (15*16^(n-1) - 14^n) = 15*16^(n-1) - 29*15^(n-1) + 14^n.
		 *   Have some 1 and have some A: (15*16^(n-1) - 14*15^(n-1)) + (15*16^(n-1) - 14*15^(n-1)) - (15*16^(n-1) - 13*14^(n-1)) = 15*16^(n-1) - 28*15^(n-1) + 13*14^(n-1).
		 *   
		 *   Have no 0 and have no 1 and have no A?    : 13^n.
		 *   Have some 0 or have some 1 or have some A?: 15*16^(n-1) - 13^n.
		 *   
		 *   Note: (Have 0 or have 1 or have A) = (Have 0) + (Have 1) + (Have A) - (Have 0 and have 1) - (Have 0 and have A) - (Have 1 and have A) + (Have 0 and have 1 and have A).
		 *   Therefore:
		 *     Have 0 and have 1 and have A
		 *     = (15*16^(n-1) - 13^n) - (15*16^(n-1) - 15^n) - (15*16^(n-1) - 14*15^(n-1)) - (15*16^(n-1) - 14*15^(n-1)) + (15*16^(n-1) - 29*15^(n-1) + 14^n) + (15*16^(n-1) - 29*15^(n-1) + 14^n) + (15*16^(n-1) - 28*15^(n-1) + 13*14^(n-1))
		 *     = 15*16^(n-1) - 43*15^(n-1) + 41*14^(n-1) - 13^n.
		 */
		public String run() {
			BigInteger sum = BigInteger.ZERO;
			for (int n = 1; n <= 16; n++) {
				sum = sum
					.add(bi(15).multiply(bi(16).pow(n - 1)))
					.subtract(bi(43).multiply(bi(15).pow(n - 1)))
					.add(bi(41).multiply(bi(14).pow(n - 1)))
					.subtract(bi(13).pow(n));
			}
			return sum.toString(16).toUpperCase();
		}
		
		
		// For syntactical convenience
		private static BigInteger bi(int n) {
			return BigInteger.valueOf(n);
		}
		
	}

Soru 172:
import java.math.BigInteger;
	import java.util.ArrayList;
	import java.util.List;
	
	
	public final class p172 implements EulerSolution {
		
		public static void main(String[] args) {
			System.out.println(new p172().run());
		}
		
		
		// Highly customizable!
		private static final int LENGTH = 18;    // >= 1
		private static final int MAX_COUNT = 3;  // >= ceiling(LENGTH / BASE), else the result is 0
		private static final int BASE = 10;      // >= 2
		
		
		/* 
		 * Let's explain how to solve this problem mostly by examples rather than by rigorous arguments.
		 * 
		 * We want to generate all the sequences of 18 decimal digits where each digit value (from '0' to '9') is used 0 to 3 times.
		 * We can partition the set of all possible sequences by considering, for each sequence, the multiset of digit value repetition counts.
		 * For example, the number 111222333444555666 has '1' used 3 times, '2' used 3 times, ..., and '6' used 3 times.
		 * When we look at these repetition counts, we see that 3 + 3 + 3 + 3 + 3 + 3 = 18. We always need them to sum to 18 ('LENGTH').
		 * 
		 * There are sequences with other repetition counts too. For example: 121212333444567890, the rep counts are 1 + 3 + 3 + 3 + 3 + 1 + 1 + 1 + 1 + 1.
		 * In fact, there are exactly 17 ways (partitions) to express 18 as an unordered sum of 10 terms with each term from 0 to 3:
		 * - 3 + 3 + 3 + 3 + 3 + 3 + 0 + 0 + 0 + 0
		 * - 3 + 3 + 3 + 3 + 3 + 2 + 1 + 0 + 0 + 0
		 * - 3 + 3 + 3 + 3 + 3 + 1 + 1 + 1 + 0 + 0
		 * - 3 + 3 + 3 + 3 + 2 + 2 + 2 + 0 + 0 + 0
		 * - 3 + 3 + 3 + 3 + 2 + 2 + 1 + 1 + 0 + 0
		 * - 3 + 3 + 3 + 3 + 2 + 1 + 1 + 1 + 1 + 0
		 * - 3 + 3 + 3 + 3 + 1 + 1 + 1 + 1 + 1 + 1
		 * - 3 + 3 + 3 + 2 + 2 + 2 + 2 + 1 + 0 + 0
		 * - 3 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 0
		 * - 3 + 3 + 3 + 2 + 2 + 1 + 1 + 1 + 1 + 1
		 * - 3 + 3 + 2 + 2 + 2 + 2 + 2 + 2 + 0 + 0
		 * - 3 + 3 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 0
		 * - 3 + 3 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1
		 * - 3 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 0
		 * - 3 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1
		 * - 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 0
		 * - 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1
		 * For example, the number 912349441125323088 is associated with the partition (3 + 3 + 3 + 3 + 2 + 2 + 1 + 1 + 0 + 0),
		 * because '1' is used 3 times, '2' is used 3 times, '3' is used 3 times, '8' is used 2 times, '9' is used 2 times,
		 * '0' is used 1 time, '5' is used 1 time, '6' is used 0 times, and '7' is used 0 times.
		 * 
		 * For each partition, we want to take the 10 decimal digit values and assign them to the terms of the partition. Here is one example assignment:
		 *   Frequency:   3 3 3 3 | 2 2 | 1 1 | 0 0
		 *   Digit value: 1 2 3 4 | 8 9 | 0 5 | 6 7
		 * But note that order does not matter if the frequency is the same - for example, this means the same as above:
		 *   Frequency:   3 3 3 3 | 2 2 | 1 1 | 0 0
		 *   Digit value: 4 1 3 2 | 8 9 | 5 0 | 7 6
		 * 
		 * For a given partition, how many ways are there to assign digit values to the frequencies?
		 * Considering the frequencies and the digit values each as a length-10 sequence (like above),
		 * we know that there are 10! raw ways to arrange the digit values. But order within a frequency does not matter.
		 * So we divide by the factorial of the repetition count of each frequency. In the example above, the answer is 10! / (4! 2! 2! 2!).
		 * (Note that this is a multinomial coefficient.)
		 * 
		 * Now that we have a partition and a digit value assignment to the frequencies, we can generate permutations.
		 * For the example above, one possible sequence (and the lexicographically lowest) is 011122233344458899 (length 18).
		 * If we permute this sequence, the partition and digit-frequency assignments will remain the same.
		 * So we want to count how many permutations this sequence has.
		 * 
		 * Given a partition and a digit-frequency assignment, how many sequences have this classification?
		 * Because there are 18 digits, there are 18! raw arrangements of digits for the sequence.
		 * But for each digit value, it is repeated k times, so we need to divide by k! to suppress identical-looking arrangements.
		 * In this example, there are 18! / (3! 3! 3! 3! 2! 2! 2! 2! 2! 2!) arrangements.
		 * 
		 * Now, all of the arguments above have no made use of the specific digit values, so there is a certain symmetry in the set of desired sequences.
		 * In particular, this means exactly 9/10th of all items have a leading zero, hence we multiply by 9/10 to get the final answer.
		 */
		public String run() {
			BigInteger ways = partitionAndCount(LENGTH, MAX_COUNT, new ArrayList<Integer>());
			
			// Multiply by (base - 1) / base to discount sequences with leading zeros
			BigInteger BASE_BI = BigInteger.valueOf(BASE);
			ways = ways.multiply(BASE_BI.subtract(BigInteger.ONE));
			ways = divideExactly(ways, BASE_BI);
			
			return ways.toString();
		}
		
		
		// Expresses 'LENGTH' as a sum of 'BASE' non-increasing terms, where terms to be added are in the range [0, max].
		// e.g. partitionAndCount(7, 2, [3, 3, 2, 2, 1]) asks us to express 18 as a sum of 5 more terms,
		// where the new terms have a sum of 7 and each is no greater than 2 and all terms are non-increasing.
		private BigInteger partitionAndCount(int sum, int max, List<Integer> terms) {
			if (terms.size() == BASE) {
				if (sum == 0)
					return countWays(terms);
				else
					return BigInteger.ZERO;
				
			} else {
				BigInteger result = BigInteger.ZERO;
				for (int i = Math.min(max, sum); i >= 0; i--) {
					terms.add(i);
					result = result.add(partitionAndCount(sum - i, i, terms));
					terms.remove(terms.size() - 1);
				}
				return result;
			}
		}
		
		
		private BigInteger countWays(List<Integer> freqs) {
			// The number of times each frequency value occurs
			int[] histogram = new int[MAX_COUNT + 1];
			for (int x : freqs)
				histogram[x]++;
			
			// Multinomial coefficient: BASE! / (histogram[0]! * histogram[1]! * ...)
			BigInteger ways = Library.factorial(BASE);
			for (int x : histogram)
				ways = ways.divide(Library.factorial(x));
			
			// Multinomial coefficient: LENGTH! / (freqs[0]! * freqs[1]! * ...)
			ways = ways.multiply(Library.factorial(LENGTH));
			for (int x : freqs)
				ways = ways.divide(Library.factorial(x));
			
			return ways;
		}
		
		
		private static BigInteger divideExactly(BigInteger x, BigInteger y) {
			BigInteger[] temp = x.divideAndRemainder(y);
			if (temp[1].signum() != 0)
				throw new IllegalArgumentException("Not divisible");
			return temp[0];
		}
		
	}
Soru 52:
import java.util.Arrays;
	

	

	public final class p052 implements EulerSolution {
		
		public static void main(String[] args) {
			System.out.println(new p052().run());
		}
		
		
		public String run() {
			for (int i = 1; ; i++) {
				if (i > Integer.MAX_VALUE / 6)
					throw new ArithmeticException("Overflow");
				if (multiplesHaveSameDigits(i))
					return Integer.toString(i);
			}
		}
		
		
		private static boolean multiplesHaveSameDigits(int x) {
			for (int i = 2; i <= 6; i++) {
				if (!Arrays.equals(toSortedDigits(x), toSortedDigits(i * x)))
					return false;
			}
			return true;
		}
		
		
		private static char[] toSortedDigits(int x) {
			char[] result = Integer.toString(x).toCharArray();
			Arrays.sort(result);
			return result;
		}
		
	}
Soru 62:
import java.math.BigInteger;
	import java.util.Arrays;
	import java.util.HashMap;
	import java.util.Map;
	

	

	public final class p062 implements EulerSolution {
		
		public static void main(String[] args) {
			System.out.println(new p062().run());
		}
		
		
		public String run() {
			int numDigits = 0;
			Map<String,Integer> lowest = new HashMap<>();
			Map<String,Integer> counts = new HashMap<>();
			for (int i = 0; ; i++) {
				String numClass = getCubeNumberClass(i);
				
				if (numClass.length() > numDigits) {
					// Process and flush data for smaller number of digits
					int min = Integer.MAX_VALUE;
					for (String nc : counts.keySet()) {
						if (counts.get(nc) == 5)
							min = Math.min(lowest.get(nc), min);
					}
					if (min != Integer.MAX_VALUE)
						return cube(min).toString();
					
					lowest.clear();
					counts.clear();
					numDigits = numClass.length();
				}
				
				if (!lowest.containsKey(numClass)) {
					lowest.put(numClass, i);
					counts.put(numClass, 0);
				}
				counts.put(numClass, counts.get(numClass) + 1);
			}
		}
		
		
		private static String getCubeNumberClass(int x) {
			char[] digits = cube(x).toString().toCharArray();
			Arrays.sort(digits);
			return new String(digits);
		}
		
		
		private static BigInteger cube(int x) {
			return BigInteger.valueOf(x).pow(3);
		}
		
	}

LeetCode
Soru 122:
/**
 * @param {number[]} prices
 * @return {number}
 */
let maxProfit = function(prices) {
  let profit = 0;

  for (let i = 1; i < prices.length; i++) {
    // only add to the profit when the price is going up
    // the difference in price is the incremental profit
    if (prices[i] > prices[i - 1]) {
      profit += prices[i] - prices[i - 1];
    } 
  }

  return profit;    
};

Soru 412:
let fizzBuzz = function(n) {
  let result = [];

  for (let i = 1; i <= n; i++) {
    if (i % 15 === 0) {
      result.push('FizzBuzz');
    } else if (i % 5 === 0) {
      result.push('Buzz');
    } else if (i % 3 === 0) {
      result.push('Fizz');
    } else {
      result.push(i.toString());
    }
  }

  return result;
};

Soru 42:
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
let isSubsequence = function(s, t) {
    if (s.length === 0) {
        return true;
    }
    
    let pointer1 = 0;
    let pointer2 = 0;
    
    while (pointer1 < s.length && pointer2 < t.length) {
        while (t.charAt(pointer2) !== s.charAt(pointer1)) {
            pointer2++;
            if (pointer2 === t.length) {
                return false;
            }
        }
        pointer1++;
        pointer2++;
    }
  
    return pointer1 === s.length;
};

Soru 322 : 
public static int numSquares(int n) {
    if (n < 2)
        return n;

    int numSquares = (int) Math.sqrt(n); // The number of squares we have depends on the sqrt of our input.
	                                     // For example, if n = 12 then we have 3 squares possible (1, 4, 9).
    int [] squares = new int[numSquares];
    for (int i = 1; i <= numSquares; i++)
        squares[i - 1] = i*i;

    int [] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i < dp.length; i++) {
        int res = Integer.MAX_VALUE;
        for (int square : squares) {
            if (square > i)
                continue;

            res = Math.min(res, dp[i - square] + 1);
        }

        dp[i] = res;
    }

    return dp[n];
}
Soru 542: 
public class _542 {
	    public int[][] updateMatrix(int[][] matrix) {
	        int m = matrix.length;
	        int n = matrix[0].length;
	

	        Queue<int[]> queue = new LinkedList<>();
	        for (int i = 0; i < m; i++) {
	            for (int j = 0; j < n; j++) {
	                if (matrix[i][j] == 0) {
	                    queue.offer(new int[]{i, j});
	                } else {
	                    matrix[i][j] = Integer.MAX_VALUE;
	                }
	            }
	        }
	

	        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
	

	        while (!queue.isEmpty()) {
	            int[] cell = queue.poll();
	            for (int[] d : dirs) {
	                int r = cell[0] + d[0];
	                int c = cell[1] + d[1];
	                if (r < 0 || r >= m || c < 0 || c >= n ||
	                        matrix[r][c] <= matrix[cell[0]][cell[1]] + 1) continue;
	                queue.add(new int[]{r, c});
	                matrix[r][c] = matrix[cell[0]][cell[1]] + 1;
	            }
	        }
	

	        return matrix;
	    }
	}


